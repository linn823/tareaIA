¿Qué puede decir de la comparación entre los métodos implementados? En concreto, los que
encontraron la solución óptima, a qué se debió? Y los que no, ¿por qué no la encontraron?

Comparamos teoricamente las siguientes busquedas: Búsqueda de profundidad(escogiendo un sucesor al azar),búsqueda por costo unifome,búsqueda greedy y A*

	-Búsqueda de profundidad(escogiendo un sucesor al azar): su forma de implemntar que se parece a método DFS, solo que en vez de buscar siguiente nodo ordenada,lo hace de manera aleatoria.
Usando stack para guadar camino generado como registro,como hemos mecionado anteriomente,este metodo se base a su aleatoridad eligiendo el camino.por lo que es importante que los nodo tener estados de visitados o no para evitar lop infinito.

	-Búsqueda greedy: este Metodo lo hice de misma forma base codigo de Búsqueda de profundidad de forma recursiva. Sabemos este metodo al momento de elegir siguiente camino considerando los costo de cada siguiente nodos para mejorar cada desicion ,sin embargo ,este deciciones no se considera todos los caminos globalmente.Por lo cual es rapido,pero mismo tiempo optimiza una soluciona pero no garantiza una mejor solucion optima.

	-A*:
	


°Comparamos cada una en que se caracteristiza.
°Comparamos sus espacio generado y su tiempo gastado 


- De los métodos vistos en clase, ¿hay alguno que NO retorne una solución (es decir, que se
mantenga realizando búsqueda ad infinitum) en este problema? Si es así, cuál? Y si no, por
qué no?
Respuesta: MetodoGreedy,Debido su forma de implemntación ,